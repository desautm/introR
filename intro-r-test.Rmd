--- 
title: "Une introduction √† R"
author: "Marc-Andr√© D√©sautels"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, package.bib]
biblio-style: apalike
link-citations: true
github-repo: rstudio/bookdown-demo
description: "Une introduction au langage R pour les √©tudiants du coll√©gial."
---

# Avant-propos {-}


<!--chapter:end:index.Rmd-->

# (PART) La pr√©sentation des donn√©es {-} 

# Introduction {#intro}

## Tibbles

Pour √™tre en mesure d'effectuer des  calculs statistiques, il nous faut une structure qui soit en mesure de garder en m√©moire une base de donn√©es. Ces structures se nomment des "tibbles" dans R.

### Pr√©requis

Pour √™tre en mesure d'utiliser le paquetage **tibble**, nous devons charger le paquetage **tibble** et le paquetage **knitr**. Pour ce faire, il suffit d'utiliser la commande suivante:

```{r}
library(tibble)
library(knitr)
```

Si vous ex√©cutez ce code et vous recevez le message d'erreur suivant "there is no package called 'tibble'", vous allez devoir installer le paquetage et ensuite charger la librairie.

```
install.packages("tibble")
library(tibble)
```

Vous faites la m√™me chose pour le paquetage **knitr**.

Vous devez installer le paquetage une seule fois, mais vous devez le charger √† chaque fois que vous d√©marrez une session en R.

### Un exemple de "tibble"

Pour comprendre ce qu'est un "tibble", nous allons utiliser deux paquetages: "nycflights13" et "diamonds". Si ce n'est pas d√©j√† fait, vous devez les installer et ensuite les charger.

```{r}
library(nycflights13)
library(ggplot2)
```

Nous allons √©tudier le paquetage "nycflights13" qui contient 5 bases de donn√©es contenant des informations concernant les vols int√©rieurs en partance de New York en 2013, √† partir des a√©roports de Newark Liberty International (EWR), John F. Kennedy International (JFK) ou LaGuardia (LGA). Les 5 bases de donn√©es sont les suivantes:

- flights: information sur les 336,776 vols
- airlines: lien entre les codes IATA de deux lettres et les noms de compagnies d'aviation (16 au total)
- planes: information de construction sur les 3 322 avions utilis√©s
- weather: donn√©es m√©t√©o √† chaque heure (environ 8 710 observations) pour chacun des trois a√©roports.
- airports: noms des a√©roports et localisations

### La base de donn√©es flights

Pour visualiser facilement une base de donn√©es sous forme "tibble", il suffit de taper son nom dans la console. Nous allons utiliser la base de donn√©es flights. Par exemple:

```{r}
flights
```

Nous allons d√©cortiquer la sortie console:

- `A tibble: 336,776 x 19`: un "tibble" est une fa√ßon de repr√©senter une base de donn√©es en R. Cette base de donn√©es poss√®de:
    * `336 776` lignes
    * `19` colonnes correspondant aux 19 variables d√©crivant chacune des observations
- `year month` `day` `dep_time` `sched_dep_time` `dep_delay` `arr_time` sont diff√©rentes colonnes, en d'autres mots des variables, de cette base de donn√©es.
- Nous avons ensuite 10 lignes d'obervations correspondant √† 10 vols
- `... with 336,766 more rows, and 12 more variables:` nous indique que 336 766 lignes et 12 autres variables ne pouvaient pas √™tre affich√©es √† l'√©cran.

Malheureusement cette sortie √©cran ne nous permet pas d'explorer les donn√©es correctement. Nous verrons √† la section \@ref(explorertibbles) comment explorer des `tibbles`.

### La base de donn√©es `diamonds` {#donneesdiamonds}

La base de donn√©es `diamonds` est compos√©e des variables suivantes:

- `price` : prix en dollars US
- `carat` : poids du diamant en grammes
- `cut` : qualit√© de la coupe (Fair, Good, Very Good, Premium, Ideal)
- `color` : couleur du diamant (J (pire) jusqu'√† D (meilleur))
- `clarity` : une mesure de la clart√© du diamant (I1 (pire), SI2, SI1, VS2, VS1, VVS2, VVS1, IF (meilleur))
- `x` : longueur en mm
- `y` : largeur en mm
- `z` : hauteur en mm
- `depth` : z / mean(x, y) = 2 * z / (x + y)
- `table` : largeur du dessus du diamant par  rapport √† son point le plus large

```{r}
diamonds
```

### Comment explorer des "tibbles" {#explorertibbles}

Voici les fa√ßons les plus communes de comprendre les donn√©es se trouvant √† l'int√©rieur d'un "tibble":

    1. En utilisant la fonction `View()` de RStudio.C'est la commande que nous utiliserons le plus fr?quemment.
    2. En utilisant la fonction `glimpse()` du paquetage knitr
    3. En utilisant la fonction `kable()`
    4. En utilisant l'op√©rateur `$` pour √©tudier une seule variable d'une base de donn√©es

1. `View()`:

√âx√©cutez `View(flights)` dans la console de RStudio et explorez la base de donn√©es obtenue. 

Nous remarquons que chaque colonnes repr√©sentent une variable diff√©rente et que ces variables peuvent √™tre de diff√©rents types. Certaines de ces variables, comme `distance`, `day` et `arr_delay` sont des variables dites quantitatives. Ces variables sont num√©riques par nature. D'autres variables sont dites qualitatives.

Si vous regardez la colonne √† l'extr√®me-gauche de la sortie de `View(flights)`, vous verrez une colonne de nombres. Ces nombres repr√©sentent les num√©ros de ligne de la base de donn√©es. Si vous vous promenez sur une ligne de m√™me nombre, par exemple la ligne 5, vous √©tudiez une unit√© statistique.

2. `glimpse`:

La seconde fa√ßon d'explorer une base de donn√©es est d'utiliser la fonction `glimpse()`. Cette fonction nous donne la majorit√© de l'information pr√©c√©dente et encore plus.

```{r}
glimpse(flights)
```

3. `kable()`:

La derni√®re fa√ßon d'√©tudier l'enti√®ret√© de la base de donn√©es est d'utiliser la fonction `kable()`. Nous allons explorer les codes des diff√©rentes compagnies d'aviation de deux fa√ßons.

```{r}
airlines
kable(airlines)
```

√Ä premi√®re vue, les deux sorties sont semblables sauf que la seconde est beaucoup plus agr√©able visuellement dans un document R Markdown.

4. L'op√©rateur `$`:

Finalement, l'op√©rateur `$` nous permet d'explorer une seule variable √† l'int√©rieur d'une base de donn√©es. Par exemple, si nous d√©sirons √©tudier la variable `name` de la base de donn√©es `airlines`, nous obtenons:

```{r}
airlines$name
```

## Types de variables

Nous pouvons utiliser diff√©rents types de variables avec le langage `R`.

### Variables qualitatives

Une variable qualitative est une variable dont les r√©sultats possibles sont des **mots**. Les diff√©rents **mots** que peuvent prendre une telle variable sont appel√©es des **modalit√©s**.

#### Variables qualitatives √† √©chelle nominale

On observe ce type de variable lorsqu‚Äôil n‚Äôy a pas d‚Äôordre croissant naturel dans les **modalit√©s** de la variable. Par exemple, la variable _couleur des cheveux_ est √† √©chelle nominale. L'ordre ¬´ blonds, bruns, roux, noirs, autre ¬ª est un ordre aussi valable que 
¬´ bruns, noirs, roux, blonds, autre ¬ª.

Dans la base de donn√©es `nycflights13`, la variable `origin` provenant des donn√©es `flights` est une variable qualitative nominale.

```{r}
unique(flights$origin)
```

Autre que l'ordre alphab√©tique, nous n'avons pas d'autre ordre logique √† imposer √† l'a√©roport d'origine des vols.

#### Variables qualitatives √† √©chelle ordinale

On observe ce type de variable lorsqu‚Äôil existe un ordre croissant dans les modalit√©s de la variable. Par exemple, la variable _degr√© de satisfaction_ est √† √©chelle ordinale. Il est possible de classer les modalit√©s en ordre d√©croissant en √©crivant : Tr√®s satisfait  >  Satisfait  >  Insatisfait  >  Tr√®s insatisfait.

Dans la base de donn√©es `diamonds`, la variable `cut` est une variable qualitative √† √©chelle ordinale.

```{r}
unique(diamonds$cut)
```

Nous remarquons que les modalit√©s de cette variable poss√®dent un ordre. Cet ordre est indiqu√© par les symboles `<` dans la sortie `R`.

### Variables quantitatives

Une variable quantitative est une variable dont les r√©sultats possibles sont des **nombres**. Les diff√©rents nombres que peuvent prendre une telle variable sont appel√©es des **valeurs**.

#### Variables quantitatives discr√®tes

On observe ce type de variable lorsque les valeurs sont √©num√©rables, c‚Äôest-√†-dire lorsqu‚Äôil n‚Äôexiste pas de valeur possible entre deux valeurs cons√©cutives. Par exemple, la variable _nombre de cours suivis pendant cette session_ est une variable quantitative discr√®te. Les valeurs de ces variables peuvent √™tre : 3, 4, 5, 6, 7,... Il est impossible de suivre 4,6 cours durant une session.

Dans la base de donn√©es `nycflights13`, la variable `engines` provenant des donn√©es `planes` est une variable quantitative discr√®te. Cette variable repr√©sente le nombre de moteurs de l'avion en question.

```{r}
unique(planes$engines)
```

Dans la sortie `R` les valeurs ne sont pas en ordre croissant mais elles le seront lorsque nous les repr√©senterons sous forme de tableau ou de graphique.

#### Variables quantitatives continues

On observe ce type de variable lorsqu‚Äôil existe une infinit√© de valeurs entre deux autres. Par exemple, la variable _masse d‚Äôun √©tudiant (en lbs)_ est une variable quantitative continue. Entre 130 et 131 lbs, il existe une infinit√© de valeurs telles que 130,54 lbs.

Dans la base de donn√©es `diamonds`, nous allons observer la variable `carat`. Voici les 25 premiers √©l√©ments de ces valeurs.

```{r}
diamonds$carat[1:25]
```

<!--chapter:end:01-intro.Rmd-->

```{r, echo = FALSE}
tabfreq <- function(x)
{
  library(knitr)
  
  mytable <- table(x)
  freq <- data.frame(mytable)
  freq_rel <- data.frame(prop.table(mytable))[2]
  freq_rel_cum <- data.frame(cumsum(prop.table(mytable)))[,1]
  
  tabfreq <- cbind(freq,freq_rel,freq_rel_cum)
  
  totalN <- sum(tabfreq[,2])
  totalF <- sum(tabfreq[,3])
  ligne <- data.frame("Total",totalN,totalF,1.0)
  names(ligne) <- colnames(tabfreq)
  tabfreq <-  rbind(tabfreq,ligne)

  
  colnames(tabfreq)<-c(deparse(substitute(x)),
                       "Fr√©quence",
                       "Fr√©quence relative",
                       "Fr√©quence relative cumul√©e")
  
  return(kable(tabfreq,digits=3,align=c("l","c","c","c")))
}
```

# Pr√©sentation des donn√©es

Pour d√©buter, nous allons charger les paquetages utiles:

```{r, message=FALSE}
library(dplyr)
library(ggplot2)
library(knitr)
```

Pour introduire la pr√©sentation des donn√©es, nous allons utiliser la base de donn√©es `mtcars` et la base de donn√©es `diamonds`, que nous avons utilis√© √† la section \@ref(donneesdiamonds). 

La base de donn√©es `mtcars` a √©t√© extraite du magazine Motor Trend de l'ann√©e 1974, et comprend la consommation d'essence et 10 autres aspects de design automobile pour 32 automobiles (mod√®les 1973-1974). 

Les 11 variables de cette base de donn√©es sont:

- `mpg` : Miles/ (US) gallon
- `cyl` : Nombre de cylindres
- `disp` : D√©placement en pouces cube
- `hp` : Nombre de chevaux-vapeur
- `drat` : Ratio
- `wt` : Poids (1000 livres)
- `qsec` : Temps pour le quart de mile
- `vs` : V/S
- `am` : Transmission (0 = automatique, 1 = manuelle)
- `gear` : Nombre de vitesses
- `carb` : Nombre de carburateurs

```{r}
mtcars
```

## Variables qualitatives

### Tableaux de fr√©quences

Nous pouvons repr√©senter des variables qualitatives sous forme de tableau. Nous allons utiliser la commande `tabfreq`. Voici comment l'utiliser pour repr√©senter la variable `cut` de la base de donn√©es `diamonds`.

```{r}
tabfreq(diamonds$cut)
```

Nous pouvons √©galement √©tudier la variable `clarity`.

```{r}
tabfreq(diamonds$clarity)
```

### Diagramme √† bandes

Pour les variables qualitatives, le diagramme √† bandes est le graphique de choix.

Pour la variable `clarity`.

```{r}
ggplot(diamonds, aes(clarity)) + geom_bar() +
  labs(
    x = "Clart√©", 
    y = "Fr√©quence", 
    title = "Diagramme √† bandes de la clart√© des diamants")
```

Pour la variable `cut`.

```{r}
ggplot(diamonds, aes(cut)) + geom_bar() +
  labs(
    x = "Coupe", 
    y = "Fr√©quence", 
    title = "Diagramme √† bandes de la coupe des diamants")
```

### Diagramme circulaire

```{r}
ggplot(diamonds, aes(x = factor(1), fill = cut)) + 
  geom_bar() +
  coord_polar(theta = "y")
```

## Variables quantitatives

### Tableaux de fr√©quences {#freqquantitatives}

Pour une variable quantitative discr√®te, il suffit d'utiliser la fonction `tabfreq` pour repr√©senter les donn√©es sous forme de tableau. Par exemple, pour la variable `cyl` de la base de donn√©es `mtcars`.

```{r}
tabfreq(mtcars$cyl)
```

Pour repr√©senter une variable quantitative continue sous forme de tableau, il faut effectuer un traitement pr√©alable sur les donn√©es. 

√âtudions la variable `carat` de la base de donn√©es `diamonds`. Si  nous tentons d'utiliser la commande `tabfreq` directement, nous allons obtenir une table beaucoup trop grande. En effet, la variable `carat` poss√®de `r length(unique(diamonds$carat))` valeurs diff√©rentes!

Pour repr√©senter la variable correctement, nous allons d√©buter par observer l'√©tendue des valeurs possibles de cette variable en utilisant la commande `range`. Nous avons donc:

```{r}
range(diamonds$carat)
```

La sortie de `R` signifie que la valeur la plus petite de `carat` est `r range(diamonds$carat)[1]`, et que la plus grande est `r range(diamonds$carat)[2]`. 

Nous voulons maintenant recoder notre variable `carat` pour obtenir des classes. Dans notre exemple, il semble ad√©quat de cr√©er des classes de largeur 1 en d√©butant √† 0 et en terminant √† 6. L'option `breaks` permet de d√©cider des classes et l'option `right` permet de fermer l'intervalle √† gauche et de l'ouvrir √† droite.

```{r}
carat_class = cut(diamonds$carat,
                  breaks = seq(from = 0, to = 6, by = 1),
                  right = FALSE)
tabfreq(carat_class)
```

### Diagramme √† b√¢tons

Pour les variables quantitatives discr√®tes, le diagramme √† b√¢tons est le graphique de choix.

```{r}
ggplot(mtcars, aes(cyl)) + 
  geom_bar(width = 0.1) + 
  labs(
    x = "Nombre de cylindres", 
    y = "Fr√©quence", 
    title = "Diagramme √† b√¢tons du nombre de cylindres")
```

### Histogramme

Pour les variables quantitatives discr√®tes, il est possible d'utiliser l'histogramme.

```{r}
ggplot(diamonds, aes(price)) + 
  geom_histogram(color = "white",binwidth = 1000, center = 500) +
  labs(
    x = "Prix", 
    y = "Fr√©quence", 
    title = "Histogramme du prix des diamants")
```

### Polygone de fr√©quences

Pour les variables quantitatives discr√®tes, il est possible d'utiliser le polygone de fr√©quences.

```{r}
ggplot(diamonds, aes(price)) + 
  geom_freqpoly(size = 1,binwidth = 1000, center = 500) + 
  labs(
    x = "Prix", 
    y = "Fr√©quence", 
    title = "Polygone de fr√©quences du prix des diamants")
```

### Ogive des pourcentages cumul√©s

Pour les variables quantitatives discr√®tes, il est possible d'utiliser l'ogive des pourcentages cumul√©s.

```{r}
ggplot(diamonds, aes(price)) + 
  stat_ecdf(pad = FALSE) + 
  labs(
    x = "Prix", 
    y = "Fr√©quence relative cumul√©e", 
    title = "Ogive des pourcentages cumul√©s du prix des diamants")
```

### Histogramme et polygone de fr√©quences

Pour les variables quantitatives discr√®tes, il est possible d'utiliser l'histogramme et le polygone de fr√©quences.

```{r}
ggplot(diamonds, aes(price)) + 
  geom_histogram(color = "white",,binwidth = 1000, center = 500) + 
  geom_freqpoly(size = 1,,binwidth = 1000, center = 500) + 
  labs(
    x = "Prix", 
    y = "Fr√©quence", 
    title = "Histogramme et polygone de fr√©quences du prix des diamants")
```

<!--chapter:end:02-presentation-donnees.Rmd-->

```{r, echo = FALSE}
tabfreq <- function(x)
{
  library(knitr)

  mytable <- table(x)
  freq <- data.frame(mytable)
  freq_rel <- data.frame(prop.table(mytable))[2]
  freq_rel_cum <- data.frame(cumsum(prop.table(mytable)))[,1]

  tabfreq <- cbind(freq,freq_rel,freq_rel_cum)

  totalN <- sum(tabfreq[,2])
  totalF <- sum(tabfreq[,3])
  ligne <- data.frame("Total",totalN,totalF,1.0)
  names(ligne) <- colnames(tabfreq)
  tabfreq <-  rbind(tabfreq,ligne)


  colnames(tabfreq)<-c(deparse(substitute(x)),
                       "Fr√©quence",
                       "Fr√©quence relative",
                       "Fr√©quence relative cumul√©e")

  return(kable(tabfreq,digits=3,align=c("l","c","c","c")))
}
```

# (PART) Les mesures associ√©es aux donn√©es {-} 

# Les diff√©rentes mesures

Dans ce chapitre, nous verrons comment utiliser `R` pour calculer les mesures importantes permettant de r√©sumer des donn√©es.

Nous allons charger les paquetages que nous allons utiliser:

```{r}
library(ggplot2)
library(nycflights13)
```

## Les mesures de tendance centrale

Les mesures de tendance centrale permettent de d√©terminer o√π se situe le ¬´ centre ¬ª des donn√©es. Les trois mesures de tendance centrale sont le mode, la moyenne et la m√©diane.

### Le mode

Le mode est la **modalit√©**, **valeur** ou **classe** poss√©dant la plus grande fr√©quence. En d‚Äôautres mots, c‚Äôest la donn√©e la plus fr√©quente. 

Puisque le mode se pr√©occupe seulement de la donn√©e la plus fr√©quente, il n‚Äôest pas influenc√© par les valeurs extr√™mes.

Lorsque le mode est une classe, il est appel√© **classe modale**. 

Le mode est not√© **Mo**. 

Le langage `R` ne poss√®de pas de fonction permettant de calculer le mode. La fa√ßon la plus simple de le calculer est d'utiliser la fonction `table` de `R`.

Par exemple, si nous voulons conna√Ætre le mode de la variable `cut` de la base de donn√©es `diamonds`:

```{r}
table(diamonds$cut)
```

Nous remarquons que le maximum est √† la modalit√© _Ideal_ avec une fr√©quence de `r max(table(diamonds$cut))`.

Si nous nous int√©ressons au mode d'une variable quantitative discr√®te comme `cyl` de la base de donn√©es `mtcars` nous obtenons:

```{r}
table(mtcars$cyl)
```

Nous remarquons que le maximum est √† la valeur _8_ avec une fr√©quence de `r max(table(mtcars$cyl))`.

Dans le cas d'une variable quantitative continue, pour calculer le mode, il faut commencer par s√©parer les donn√©es en classes. Nous utiliserons les m√™mes classes utilis√©es √† la section \@ref(freqquantitatives)

```{r}
carat_class = cut(diamonds$carat,
                  breaks = seq(from = 0, to = 6, by = 1),
                  right = FALSE)
table(carat_class)
```

La classe modale est donc la classe _[0,1)_ avec une fr√©quence de `r max(table(carat_class))`.

### La m√©diane

La m√©diane, not√©e **Md**, est la valeur qui s√©pare une s√©rie de donn√©es class√©e en ordre croissant en deux parties √©gales. 

La m√©diane √©tant la valeur du milieu, elle est la valeur o√π le pourcentage cumul√© atteint 50%. 

Puisque la m√©diane se pr√©occupe seulement de d√©terminer o√π se situe le centre des donn√©es, elle n‚Äôest pas influenc√©e par les valeurs extr√™mes. Elle est donc une mesure de tendance centrale plus fiable que la moyenne.

> Important : La m√©diane n‚Äôest d√©finie que pour les variables quantitatives. En effet, si vous tentez d'utiliser la m√©diane pour des donn√©es autres que num√©riques, `R` vous donnera un message d'erreur.

La fonction `median` permet de calculer la m√©diane en langage `R`.

Par exemple, pour calculer la m√©diane de la variable `carat` de la base de donn√©es `diamonds`, nous avons:

```{r}
median(diamonds$carat)
```

Ceci signifie que 50% des diamants ont une valeur en carat inf√©rieure ou √©gale √† `r median(diamonds$carat)` et que 50% des diamants ont une valeur en carat sup√©rieure ou √©gale √† `r median(diamonds$carat)`.

Nous pouvons aussi obtenir que la m√©diane de la variable `price` de la base de donn√©es `diamonds` est donn√©e par:

```{r}
median(diamonds$price)
```

### La moyenne

La moyenne est la valeur qui pourrait remplacer chacune des donn√©es d‚Äôune s√©rie pour que leur somme demeure identique. Intuitivement, elle repr√©sente le centre d‚Äô√©quilibre d‚Äôune s√©rie de donn√©es. La somme des distances qui s√©pare les donn√©es plus petites que la moyenne devrait √™tre la m√™me que la somme des distances qui s√©pare les donn√©es plus grandes. 

> Important : La moyenne n‚Äôest d√©finie que pour les variables quantitatives. En effet, si vous tentez d'utiliser la moyenne pour des donn√©es autres que num√©riques, `R` vous donnera un message d'erreur.

La fonction `mean` permet de calculer la moyenne en langage `R`.

Par exemple, pour calculer la moyenne de la variable `carat` de la base de donn√©es `diamonds`, nous avons:

```{r}
mean(diamonds$carat)
```

Nous pouvons aussi obtenir que la moyenne de la variable `price` de la base de donn√©es `diamonds` est donn√©e par:

```{r}
mean(diamonds$price)
```

## Les mesures de dispersion

Les mesures de tendance centrale (mode, moyenne et m√©diane) ne permettent pas de d√©terminer si une s√©rie de donn√©es est principalement situ√©e autour de son centre, ou si au contraire elle est tr√®s dispers√©e. 

Les mesures de dispersion, elles, permettent de d√©terminer si une s√©rie de donn√©es est centralis√©e autour de sa moyenne, ou si elle est au contraire tr√®s dispers√©e. 

Les mesures de dispersion sont l‚Äô√©tendue, la variance, l‚Äô√©cart-type et le coefficient de variation. 

### L'√©tendue

La premi√®re mesure de dispersion, l‚Äô√©tendue, est la diff√©rence entre la valeur maximale et la valeur minimale.

L‚Äô√©tendue ne tenant compte que du maximum et du minimum, elle est grandement influenc√©e par les valeurs extr√™mes. Elle est donc une mesure de dispersion peu fiable.

La fonction `range` permet de calculer l'√©tendue d'une variable en langage `R`.

Par exemple, pour calculer l'√©tendue de la variable `carat` de la base de donn√©es `diamonds`, nous avons:

```{r}
range(diamonds$carat)
```

Nous pouvons donc calculer l'√©tendue de la variable `carat` en soustrayant les deux valeurs obtenues par la fonction `range`, c'est-√†-dire que l'√©tendue est  `r range(diamonds$carat)[2]`-`r range(diamonds$carat)[1]` = `r range(diamonds$carat)[2]-range(diamonds$carat)[1]`.

### La variance

La variance sert principalement √† calculer l‚Äô√©cart-type, la mesure de dispersion la plus connue.

> Attention : Les unit√©s de la variance sont des unit√©s^2^.

La fonction `var` permet de calculer la variance d'une variable en langage `R`.

Par exemple, pour calculer la variance de la variable `carat` de la base de donn√©es `diamonds`, nous avons:

```{r}
var(diamonds$carat)
```

Ceci signifie que la variance de la variable `carat` est `r var(diamonds$carat)` carat^2^.

### L'√©cart-type

L‚Äô√©cart-type est la mesure de dispersion la plus couramment utilis√©e. Il peut √™tre vu comme la ¬´ moyenne ¬ª des √©carts entre les donn√©es et la moyenne.

Puisque l‚Äô√©cart-type tient compte de chacune des donn√©es, il est une mesure de dispersion beaucoup plus fiable que l‚Äô√©tendue.

Il est d√©fini comme la racine carr√©e de la variance.

La fonction `sd` permet de calculer l''√©cart-type d'une variable en langage `R`.

Par exemple, pour calculer l'√©cart-type de la variable `carat` de la base de donn√©es `diamonds`, nous avons:

```{r}
sd(diamonds$carat)
```

Ceci signifie que l'√©cart-type de la variable `carat` est `r sd(diamonds$carat)` carat.

### Le coefficient de variation

Le coefficient de variation, not√© C. V., est calcul√© comme suit : 

\begin{equation}
C.V. = \dfrac{\text{ecart-type}}{\text{moyenne}}\times 100\%
\end{equation}

Si le coefficient est inf√©rieur √† 15%, les donn√©es sont dites **homog√®nes**. Cela veut dire que les donn√©es sont situ√©es pr√®s les unes des autres.

Dans le cas contraire, les donn√©es sont dites **h√©t√©rog√®nes**. Cela veut dire que les donn√©es sont tr√®s dispers√©es.

> Important : Le coefficient de variation ne poss√®de pas d‚Äôunit√©, outre le symbole de pourcentage.

Il n'existe pas de fonctions en `R` permettant de calculer directement le coefficient de variation. Par contre, nous pouvons utiliser en conjonction les fonctions `sd` et `mean` pour le calculer.

Par exemple, pour calculer le coefficient de variation de la variable `carat` de la base de donn√©es `diamonds`, nous avons:

```{r}
sd(diamonds$carat)/mean(diamonds$carat)*100
```

Le C.V. de la variable `carat` est donc `r sd(diamonds$carat)/mean(diamonds$carat)*100` %, ce qui signifie que les donn√©es sont `r ifelse(sd(diamonds$carat)/mean(diamonds$carat)<=0.15,"homog√®nes","h√©t√©rog√®nes")`, car le coefficient de variation est `r ifelse(sd(diamonds$carat)/mean(diamonds$carat)<=0.15,"plus petit ou √©gal √† 15%","plus grand que 15%")`.

## Les mesures de position

Les mesures de position permettent de situer une donn√©e par rapport aux autres. Les diff√©rentes mesures de position sont la cote Z, les quantiles et les rangs.

Tout comme les mesures de dispersion, celles-ci ne sont d√©finies que pour une variable quantitative.

### La cote z

Cette mesure de position se base sur la moyenne et l‚Äô√©cart-type.

La cote Z d‚Äôune donn√©e x est calcul√©e comme suit : 

\begin{equation}
Z = \dfrac{x-\text{moyenne}}{\text{ecart-type}}
\end{equation}

> Important : La cote z ne poss√®de pas d'unit√©s.

Une cote Z peut √™tre positive, n√©gative ou nulle. 

| Cote Z | Interpr√©tation |
|-------:|:---------------|
| Z>0 | donn√©e sup√©rieure √† la moyenne | 
| Z<0 | donn√©e inf√©rieure √† la moyenne |
| Z=0 | donn√©e √©gale √† la moyenne |

Il n'existe pas de fonctions en `R` permettant de calculer directement la cote Z. Par contre, nous pouvons utiliser en conjonction les fonctions `sd` et `mean` pour la calculer.

Par exemple, si nous voulons calculer la cote Z d'un diamant de 3 carats, nous avons:

```{r}
(3-mean(diamonds$carat))/sd(diamonds$carat)
```

### Les quantiles

Un quantile est une donn√©e qui correspond √† un certain pourcentage cumul√©.

Parmi les quantiles, on distingue les quartiles, les quintiles, les d√©ciles et les centiles. 

- Les quartiles Q~1~, Q~2~ et Q~3~, s√©parent les donn√©es en quatre parties √©gales.
Environ 25% des donn√©es sont inf√©rieures ou √©gales √† Q~1~.
Environ 50% des donn√©es sont inf√©rieures ou √©gales √† Q~2~.
Environ 75% des donn√©es sont inf√©rieures ou √©gales √† Q~3~.
- Les quintiles V~1~, V~2~, V~3~ et V~4~, s√©parent les donn√©es en cinq parties √©gales.
Environ 20% des donn√©es sont inf√©rieures ou √©gales √† V~1~.
Environ 40% des donn√©es sont inf√©rieures ou √©gales √† V~2~.
Etc.
- Les d√©ciles D~1~, D~2~, ..., D~8~ et D~9~, s√©parent les donn√©es en dix parties √©gales. 
Environ 10% des donn√©es sont inf√©rieures ou √©gales √† D~1~. 
Environ 20% des donn√©es sont inf√©rieures ou √©gales √† D~2~.
Etc.
- Les centiles C~1~, C~2~, ..., C~98~ et C~99~, s√©parent les donn√©es en cent parties √©gales.
Environ 1% des donn√©es sont inf√©rieures ou √©gales √† C~1~.
Environ 2% des donn√©es sont inf√©rieures ou √©gales √† C~2~.
Etc.

> Il est utile de noter que certains quantiles se recoupent. 

La fonction `quantile` permet de calculer n'importe quel quantile d'une variable en langage `R`. Il suffit d'indiquer la variable √©tudi√©e ainsi que le pourcentage du quantile voulu.

Par exemple, si nous voulons calculer D~1~ pour la variable `carat`, nous allons utiliser la fonction `quantile` avec une probabilit√© de 0,1.

```{r}
quantile(diamonds$carat, 0.1)
```

Ceci implique que 10% des diamants ont une valeur en carat inf√©rieure ou √©gale √† `r quantile(diamonds$carat, 0.1)` carat.

Nous pouvons calculer le troisi√®me quartile Q~3~ de la variable `price` en utilisant la fonction `quantile` avec une probabilit√© de 0,75.

```{r}
quantile(diamonds$price, 0.75)
```

Ceci implique que 75% des diamants ont un prix en dollars inf√©rieur ou √©gal √† `r quantile(diamonds$price, 0.75)` $.

### La commande `summary`

La commande `summary` produit un sommaire contenant six mesures importantes:

1. `Min` : le minimum de la variable
2. `1st Qu.`: Le premier quartile, Q~1~, de la variable
3. `Median` : La m√©diane de la variable
4. `Mean` : La moyenne de la variable
5. `3rd Qu.` : Le troisi√®me quartile, Q~3~, de la variable
6. `Max` : Le maximum de la variable

Nous pouvons donc produire le sommaire de la variable `price` de la base de donn√©es `diamonds` de la fa√ßon suivante:

```{r}
summary(diamonds$price)
```

### Le rang centile

Un rang centile repr√©sente le pourcentage cumul√©, *exprim√© en nombre entier*, qui correspond √† une certaine donn√©e. Nous d√©terminerons les rangs centiles pour les variables continues seulement.

Les rangs centiles sont donc exactement l‚Äôinverse des centiles.

Il n'existe pas de fonctions dans `R` permettant de trouver directement le rang centile, mais il est facile d'utiliser la fonction `mean` pour le trouver. 

Par exemple, si nous voulons trouver le rang centile d'un diamant qui co√ªte 500\$, il suffit d'utiliser la commande suivante. La commande calcule la moyenne de toutes les valeurs en dollars des diamants co√ªtant 500\$ ou moins.

```{r}
mean(diamonds$price<=500)
```

Ceci signifie que pour un diamant de 500\$, il y a `r mean(diamonds$price<=500)*100` % des diamants qui ont une valeur √©gale ou inf√©rieure.

<!--chapter:end:03-mesures.Rmd-->

# Les s√©ries chronologiques

D√©butons par charger les paquetages qui nous seront utiles.

```{r}
library(gapminder)
library(nycflights13)
library(ggplot2)
library(dplyr)
```

Une s√©rie chronologique est un ensemble de valeurs observ√©es d‚Äôune variable quantitative. Elle permet d‚Äôanalyser l‚Äô√©volution de cette variable dans le temps dans le but √©ventuel de faire des pr√©visions.

## Les graphiques

Nous allons d√©buter par utiliser la base de donn√©es `nycflights13`. Nous allons √©tudier la temp√©rature au mois de janvier 2013 √† l'a√©roport Newark (code "EWR" dans la variable `origin`). La variable `weather` de la base de donn√©es contient ces informations mais nous devons tout d'abord filtrer les donn√©es pour ne conserver que celles qui correspondent √† Newark et au mois de janvier.

La commande suivante permet de faire ce filtrage. Vous n'avez pas besoin de comprendre la syntaxe.

```{r}
meteo_janvier_ewr <- weather %>% 
  filter(origin == "EWR" & month == 1 )
```

Nous pouvons maintenant tracer les donn√©es obtenues:

```{r}
ggplot(meteo_janvier_ewr, aes(x = time_hour, y = temp)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Heures du mois de janvier",
    y = "Temp√©rature en degr√©e Farhenheit",
    title = "R√©partition de la temp√©rature au mois de janvier en fonction de l'heure"
  )
```

Nous pouvons aussi utiliser la paquetage `gapminder` qui contient des donn√©es sur l'esp√©rance de vie. Comme pr√©c√©demment, nous allons d√©buter par filtrer les donn√©es provenant uniquement du Canada.

```{r}
gap_canada <- gapminder %>%
  filter(country == "Canada")
```

Nous pouvons maintenant tracer les donn√©es obtenues:

```{r}
ggplot(gap_canada, aes(x = year, y = lifeExp)) + 
  geom_line() + geom_point() +
  labs(
    x = "Ann√©e",
    y = "Esp√©rance de vie",
    title = "R√©partition de l'esp√©rance de vie au Canada en fonction de l'ann√©e")
```

## Les mesures

### La variation absolue

La variation absolue mesure l‚Äôaugmentation (ou la diminution) subie par une variable dans le temps. Pour calculer la variation absolue entre un moment A ant√©rieur √† un moment B, on utilise la formule ci-dessous :

\begin{equation}
\Delta V = V_B - V_A
\end{equation}

o√π V~B~ est la valeur de la variable au temps B et V~A~ est la valeur de la variable au temps A.

> Remarque : Les unit√©s de la variation absolue sont les m√™mes que celles de la variable √©tudi√©e.

Si nous voulons conna√Ætre la variation absolue de la population du Canada, nous allons devoir ajouter une colonne √† notre base de donn√©es `gap_canada`. Encore une fois, il n'est pas n√©cessaire de comprendre la syntaxe. Nous ajoutons une colonne variation absolue, not√©e `var_abs`, √† notre base de donn√©es `gap_canada`.

```{r}
gap_canada <- gap_canada %>%
  mutate(var_abs = pop - lag(pop))
```

Nous pouvons maintenant repr√©senter la variable √† l'aide d'un graphique.

```{r, warning = FALSE}
ggplot(gap_canada, aes(x = year, y = var_abs)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Ann√©e",
    y = "Variation absolue de la population",
    title = "R√©partition de la variation absolue de la population du Canada selon l'ann√©e"
  )
```

### La variation moyenne

La variation moyenne mesure l‚Äôaugmentation (ou la diminution) moyenne subie par une variable par unit√© de temps. La variation moyenne entre les moments ùê¥ et ùêµ est donn√©e par :

\begin{equation}
\Delta V_{moy} = \dfrac{V_B - V_A}{B-A}
\end{equation}

> Remarque : Les unit√©s de la variation moyenne sont les unit√©s de la variable √©tudi√©e par unit√© de temps.

Si nous voulons conna√Ætre la variation moyenne de la population du Canada, nous allons devoir ajouter une colonne √† notre base de donn√©es `gap_canada`. Encore une fois, il n'est pas n√©cessaire de comprendre la syntaxe. Nous ajoutons une colonne variation moyenne, not√©e `var_moy`, √† notre base de donn√©es `gap_canada`.

```{r}
gap_canada <- gap_canada %>%
  mutate(var_moy = (pop - lag(pop))/(year-lag(year)))
```

Nous pouvons maintenant repr√©senter la variable √† l'aide d'un graphique.

```{r, warning = FALSE}
ggplot(gap_canada, aes(x = year, y = var_moy)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Ann√©e",
    y = "Variation moyenne de la population",
    title = "R√©partition de la variation moyenne de la population du Canada selon l'ann√©e"
  )
```

### La variation relative (pourcentage de variation)

La variation relative exprime *en pourcentage* la variation subie par une variable entre les moments ùê¥ et ùêµ. Le pourcentageest donn√© par:

\begin{equation}
\Delta V_{\%} = \dfrac{V_B - V_A}{V_A}\times 100
\end{equation}

> Remarque : Il n‚Äôy a pas d‚Äôunit√© autre que le symbole de pourcentage.

Si nous voulons conna√Ætre la variation relative de la population du Canada, nous allons devoir ajouter une colonne √† notre base de donn√©es `gap_canada`. Encore une fois, il n'est pas n√©cessaire de comprendre la syntaxe. Nous ajoutons une colonne variation relative, not√©e `var_rel`, √† notre base de donn√©es `gap_canada`.

```{r}
gap_canada <- gap_canada %>%
  mutate(var_rel = (pop - lag(pop))/lag(pop) * 100)
```

Nous pouvons maintenant repr√©senter la variable √† l'aide d'un graphique.

```{r, warning = FALSE}
ggplot(gap_canada, aes(x = year, y = var_rel)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Ann√©e",
    y = "Variation relative de la population",
    title = "R√©partition de la variation relative de la population du Canada selon l'ann√©e"
  )
```

## Les donn√©es construites


<!--chapter:end:04-series-chronologiques.Rmd-->

# (PART) La combinatoire et les probabilit√©s {-} 

# La combinatoire

## La factorielle

Pour calculer la factorielle d'un nombre en `R`, il faut utiliser la commande `factorial`. Par exemple, si nous voulons calculer 6!:

```{r}
factorial(6)
```

## Les combinaisons

Pour calculer le nombre de combinaisons lorsque nous choisissons $k$ objets parmi $n$ (**sans** ordre), c'est-√†-dire $C_k^n$, nous utilisons la commande `choose(n,k)`. Par exemple, si nous voulons calculer le nombre de combinaisons possibles au loto 6-49, $C_6^{49}$, nous avons:

```{r}
choose(49,6)
```

## Les arrangements

Pour calculer le nombre d'arrangements lorsque nous choisissons $k$ objets parmi $n$ (**avec** ordre), c'est-√†-dire $A_k^n$, nous utilisons les commandes `choose(n,k)` et `factorial`. En effet, nous savons que:

\begin{equation}
A_k^n = C_k^n \cdot k!
\end{equation}

et donc on peut calculer un arrangement en effectuant `choose(n,k)*factorial(k)`. Si nous voulons calculer le nombre de comit√©s de 5 personnes nous pouvons former en choisissant parmi 12 personnes, $A_5^{12}$, nous avons:

```{r}
choose(12,5)*factorial(5)
```


<!--chapter:end:05-combinatoire.Rmd-->

# Les lois de probabilit√©s

Pour √™tre en mesure d'utiliser les lois de probabilit√©s en langage `R`, il faut charger le paquetage `stats`.

```{r}
library(stats)
library(ggplot2)
```

Chaque distribution en `R` poss√®de quatre fonctions qui lui sont associ√©es. Premi√®rement, la fonction poss√®de un _nom racine_, par exemple le _nom racine_ pour la distribution *binomiale* est `binom`. Cette racine est pr√©c√©d√©e par une de ces quatre lettre:

- `p` pour *probabilit√©*, qui repr√©sente la fonction de r√©partition
- `q` pour *quantile*, l'inverse de la fonction de r√©partition
- `d` pour *densit√©*, la fonction de densit√© de la distribution
- `r` pour *random*, une variable al√©atoire suivant la distribution sp√©cifi√©e.

Pour la loi binomiale par exemple, ces fonctions sont `pbinom`, `qbinom`, `dbinom` et `rbinom`.

## Les lois de probabilit√©s discr√®tes

### La loi binomiale

Le _nom racine_ pour la loi binomiale est `binom`.

Soit $X$: le nombre de succ√®s en $n$ essais et $X\sim B(n,p)$. Voici la fa√ßon de calculer des probabilit√©s pour la loi binomiale √† l'aide de `R`:

|Probabilit√©s|Commande `R`|
|-----------:|:-----------|
|$P(X=k)$    |`dbinom(k, n, p)`|
|$P(i\leq X \leq j)$ | `sum(dbinom(i:j, n, p))`|
|$P(X\leq k)$ | `pbinom(k, n, p)` |
|$P(X>k)$ | `1-pbinom(k, n, p)` |

Soit $X$ la variable al√©atoire comptant le nombre de face 2 que nous obtenons en lan√ßant un d√© √† quatre reprises. Nous avons que $X\sim B(4,\frac{1}{6})$. Si nous voulons calculer $P(X=3)$, nous aurons:

```{r}
dbinom(3,4,1/6)
```

Nous avons donc une probabilit√© de `r dbinom(3,4,1/6)*100`% d'obtenir 3 fois la face deux en lan√ßant un d√© √† quatres reprises.

Nous pouvons repr√©senter graphiquement la loi binomiale. Soit $X~B(10,1/4)$. Nous aurons:

```{r}
fbinom <- data.frame(x = 0:10, y = dbinom(0:10, 10, 1/4))
ggplot(fbinom, aes(x = x, y = y)) +
  geom_bar(width = 0.1, stat = "identity") +
  labs(
    x = "Nombre de succ√®s",
    y = "Probabilit√©",
    title = "R√©partition de la probabilit√© de la loi binomiale en fonction du nombre de succ√®s"
  )
```

### La loi de Poisson

Le _nom racine_ pour la loi de Poisson est `pois`.

Soit $X$: le nombre d'√©v√©nements dans un intervalle fix√© et $X\sim Po(\lambda)$. Voici la fa√ßon de calculer des probabilit√©s pour la loi de Poisson √† l'aide de `R`:

|Probabilit√©s|Commande `R`|
|-----------:|:-----------|
|$P(X=k)$    |`dpois(k, lambda)`|
|$P(i\leq X \leq j)$ | `sum(dpois(i:j, lambda))`|
|$P(X\leq k)$ | `ppois(k, lambda)` |
|$P(X>k)$ | `1-ppois(k, lambda)` |

Soit $X$ le nombre d'erreurs dans une page. Si une page contient en moyenne une demie erreur alors $X\sim Po(1/2)$. Si nous voulons calculer $P(X=2)$, nous aurons:

```{r}
dpois(2, 1/2)
```

Nous avons donc une probabilit√© de `r dpois(2, 1/2)*100`% d'obtenir deux erreurs sur une page.

Nous pouvons repr√©senter graphiquement la loi de Poisson. Soit $X\sim Po(1/2)$. Nous aurons:

```{r}
fpois <- data.frame(x = 0:10, y = dpois(0:10, 1/2))
ggplot(fpois, aes(x = x, y = y)) +
  geom_bar(width = 0.1, stat = "identity") +
  labs(
    x = "Nombre d'√©v√©nements",
    y = "Probabilit√©",
    title = "R√©partition de la probabilit√© de la loi de Poisson en fonction du nombre d'√©v√©nements"
  )
```

### La loi g√©om√©trique

Le _nom racine_ pour la loi g√©om√©trique est `geom`.

Soit $X$: le nombre d'√©checs avant d'obtenir un succ√®s et $X\sim G(p)$. Voici la fa√ßon de calculer des probabilit√©s pour la loi g√©om√©trique √† l'aide de `R`:

|Probabilit√©s|Commande `R`|
|-----------:|:-----------|
|$P(X=k)$    |`dgeom(k, p)`|
|$P(i\leq X \leq j)$ | `sum(dgeom(i:j, p))`|
|$P(X\leq k)$ | `pgeom(k, p)` |
|$P(X>k)$ | `1-pgeom(k, p)` |

Soit $X$ le nombre d'√©checs avant d'avoir un premier succ√®s. Si la probabilit√© de succ√®s est $\frac{1}{5}$ alors $X\sim G(1/5)$. Si nous voulons calculer $P(X=6)$, nous aurons:

```{r}
dgeom(6, 1/5)
```

Nous avons donc une probabilit√© de `r dgeom(6, 1/5)*100`% d'obtenir 6 √©checs avant un premier succ√®s.

Nous pouvons repr√©senter graphiquement la loi g√©om√©trique. Soit $X\sim G(1/5)$. Nous aurons:

```{r}
fgeom <- data.frame(x = 0:10, y = dgeom(0:10, 1/5))
ggplot(fgeom, aes(x = x, y = y)) +
  geom_bar(width = 0.1, stat = "identity") +
  labs(
    x = "Nombre d'√©v√©nements",
    y = "Probabilit√©",
    title = "R√©partition de la probabilit√© de la loi g√©om√©trique en fonction du nombre d'√©checs avant le premier succ√®s"
  )
```

> Remarque : Pour la loi g√©om√©trique, on rencontre parfois cette d√©finition : la probabilit√© p'(k) est la probabilit√©, lors d'une succession d'√©preuves de Bernoulli ind√©pendantes, d'obtenir k √©checs avant un succ√®s. On remarque qu'il ne s'agit que d'un d√©calage de la pr√©c√©dente loi g√©om√©trique. Si $X$ suit la loi $p$, alors $X+1$ suit la loi $p'$.

### La loi hyperg√©om√©trique

Le _nom racine_ pour la loi hyperg√©om√©trique est `hyper`.

On tire sans remise $n$ objets d'un ensemble de $N$ objets dont $A$
poss√®dent une caract√©ristique particuli√®re (et les autres $B=N-A$ ne la poss√®dent pas). Soit $X$ le nombre d'objets de l'√©chantillon qui poss√®dent la caract√©ristique. Nous avons que $X\sim H(N,A,n)$.

Voici la fa√ßon de calculer des probabilit√©s pour la loi hyperg√©om√©trique √† l'aide de `R`:

|Probabilit√©s|Commande `R`|
|-----------:|:-----------|
|$P(X=k)$    |`dhyper(k, A, B, n)`|
|$P(i\leq X \leq j)$ | `sum(dhyper(i:j, A, B, n))`|
|$P(X\leq k)$ | `phyper(k, A, B, n)` |
|$P(X>k)$ | `1-phyper(k, A, B, n)` |

Soit $X$ le nombre de boules blanches de l'√©chantillon de taille 4. Si l'urne contient 5 boules blanches et 8 boules noires, nous avons $X\sim H(13,5,4)$. Si nous voulons calculer $P(X=2)$, nous aurons:

```{r}
dhyper(2, 5, 8, 4)
```

Nous avons donc une probabilit√© de `r dhyper(2, 5, 8, 4)*100`% de piger 2 boules blanches dans un √©chantillon de taille 4.

Nous pouvons repr√©senter graphiquement la loi hyperg√©om√©trique. Soit $X\sim H(13,5,4)$. Nous aurons:

```{r}
fhyper <- data.frame(x = 0:4, y = dhyper(0:4, 5, 8, 4))
ggplot(fhyper, aes(x = x, y = y)) +
  geom_bar(width = 0.1, stat = "identity") +
  labs(
    x = "Nombre d'√©v√©nements",
    y = "Probabilit√©",
    title = "R√©partition de la probabilit√© de la loi hyperg√©om√©trique en fonction du nombre de boules blanches dans l'√©chantillon"
  )
```

## Les lois de probabilit√©s continues

### La loi normale

Le _nom racine_ pour la loi normale est `norm`.

Si $X$ suit une loi normale de moyenne $\mu$ et de variance $\sigma^2$, nous avons $X\sim N(\mu,\sigma^2)$.

Voici la fa√ßon de calculer des probabilit√©s pour la loi normale √† l'aide de `R`:

|Probabilit√©s|Commande `R`|
|-----------:|:-----------|
|$P(i\leq X \leq j)$ | `pnorm(j, mu, sigma)-pnorm(i, mu, sigma)`|
|$P(X\leq k)$ | `pnorm(k, mu, sigma)` |
|$P(X>k)$ | `1-pnorm(k, mu, sigma)` |

Soit $X\sim N(3,25)$ une variable al√©atoire suivant une loi normale de moyenne 3 et de variance 25. Si nous voulons calculer la probabilit√© $P(1.25<X<3.6)$ en `R`, nous pouvons utiliser la commande suivante:

```{r}
pnorm(3.6, 3, 5) - pnorm(1.25, 3, 5)
```

La probabilit√© que notre variable al√©atoire se trouve entre 1.25 et 3.6 est donc `r (pnorm(3.6, 3, 5) - pnorm(1.25, 3, 5))*100` %.

Nous pouvons repr√©senter graphiquement la loi normale. Soit $X\sim N(0,1)$. Nous aurons:

```{r}
ggplot(data = data.frame(x = c(-4, 4)), aes(x)) +
  stat_function(fun = dnorm, args = list(mean = 0, sd = 1))
```

###  La loi de Student

Le _nom racine_ pour la loi de Student est `t`.

Si $X$ suit une loi de Student √† $\nu$ degr√©s de libert√©, nous avons $X\sim T_{\nu}$.

Voici la fa√ßon de calculer des probabilit√©s pour la loi de Student √† l'aide de `R`:

|Probabilit√©s|Commande `R`|
|-----------:|:-----------|
|$P(i\leq X \leq j)$ | `pt(j, nu)-pt(i, nu)`|
|$P(X\leq k)$ | `pt(k, nu)` |
|$P(X>k)$ | `1-pt(k, nu)` |

Soit $X\sim T_5$ une variable al√©atoire suivant une loi de Student √† 5 degr√©s de libert√©. Si nous voulons calculer la probabilit√© $P(X>3)$ en `R`, nous pouvons utiliser la commande suivante:

```{r}
1 - pt(3, 5)
```

La probabilit√© que notre variable al√©atoire soit plus grande que 3 est donc `r (1 - pt(3, 5))*100` %.

Nous pouvons repr√©senter graphiquement la loi de Student. Soit $X\sim T_{5}$. Nous aurons:

```{r}
ggplot(data = data.frame(x = c(-4, 4)), aes(x)) +
  stat_function(fun = dt, args = list(df = 5))
```

<!--chapter:end:06-lois-probabilites.Rmd-->

# (PART) L'estimation de param√®tres et les tests d'hypoth√®ses {-} 

# Les distributions d'√©chantillonnage

## Paquetages utiles {-}

Chargeons tous les paquetages qui nous seront utiles.

```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(okcupiddata)
library(mosaic)
```

## L'√©chantillonnage

Le paquetage `okcupiddata` [@R-okcupiddata] se trouve [ici](https://github.com/rudeboybert/okcupiddata).

```{r}
profiles_subset <- profiles %>% 
  filter(between(height, 55, 85))
```

```{r}
ggplot(profiles_subset,aes(height)) +
  geom_histogram(bins = 20, color = "white") +
  labs(
    x = "Taille",
    y = "Fr√©quence",
    title = "Histogramme"
  )
```

```{r}
knitr::include_app("http://ismay.shinyapps.io/okcupidheights/")
```



<!--chapter:end:07-distributions-echantillonnage.Rmd-->

# L'estimation par intervalle de confiance


<!--chapter:end:08-estimation.Rmd-->

# Les tests d'hypoth√®ses


<!--chapter:end:09-tests-hypotheses.Rmd-->

`r if (knitr:::is_html_output()) '# Bibliographie {-}'`

<!--chapter:end:99-bibliographie.Rmd-->

